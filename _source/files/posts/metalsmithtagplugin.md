---
title: Creating a Metalsmith tag plugin
author: David
tags: [metalsmith]
date: 2014-08-09
excerpt: A walkthrough of creating a tag plugin for Metalsmith
template: post.html
---

## Creating the plugin

When we first set up this blog, there was no tag plugin for Metalsmith. Now there is a [pretty solid-looking one](https://github.com/totocaster/metalsmith-tags), but we had to roll our own. This post walks through that code, serving mostly as a rundown of how to create a Metalsmith plugin.

Metalsmith is mostly used as a static site generator, but it is really an all-purpose tool for iterating over files in a folder structure and doing something with them. Everything you want to do is a plugin. Here's what the Metalsmith code looks like for generating this blog:

```javascript
Metalsmith(__dirname)
  .use(collections({articles: {pattern:'posts/*.md',sortBy:"date",reverse:true}}))
  .use(tags({path:"tags/"}))
  .use(metallic({classPrefix:''}))
  .use(markdown())
  .use(sass({outputStyle:"expanded"}))
  .use(permalinks({pattern: 'posts/:title'}))
  .use(templates({engine: 'handlebars',directory: './templates'}))
  .source('./files')
  .destination('../.')
  .build(function(e,h){if (e){throw e;}});
```

Each `use` call is a plugin. Abstracting the actual file transformations to plugins is a very conscious call made by Metalsmith creators, serving to keep the Metalsmith API very small and lean.

Note the second row, `.use(tags({...}))`. That's our plugin! As you can see, each plugin is actually a function, that takes an options object for an argument.

Here's the skeleton of the plugin code:

```javascript
tags= function(opts){

  // commonly set default options here

  // return the function to be given to the `.use` call.
  return function(files, metalsmith, done){

    // ...do something with `files` here...

    done();
  };
};
```

The plugin function is given three arguments:

*    The `files` object given to the plugin function contains information of all processed files so far. The keys are the paths to the files. A plugin commonly loops through all these files, editing them accordingly. 
*    The `metalsmith` object exposes the Metalsmith API. A common usecase is to access the metadata through `metalsmith.metadata()` and read/edit that.
*    To allow plugins to do asynchronous stuff, control isn't handed back to Metalsmith until the `done` callback is called.

Each `file` object contains the contents of the file, and also information from optional YAML frontmatter. For example, here's the YAML for this very blog post:

```yaml
---
title: Creating a Metalsmith tag plugin
author: David
tags: [metalsmith]
date: 2014-08-09
excerpt: A walkthrough of creating a tag plugin for Metalsmith
template: post.html
---
```

Note the `tags` data - that's of course meant to be consumed by our tags plugin! 

First we need to consider what we actually want our plugin to do. What we need are two things;

*    We want to add a page for each tag, listing all posts for that tag. These files need to be generated by the plugin.
*    We want to add a page listing all tags found in the blog, along with a post count for each tag. The plugin could generate this file, or simply expose data making such a file easy to set up. We've elected to go with the latter, as there's too many decisions going into creating such a file.

Here's the full code for our tag plugin, meeting the needs outlined above:

```javascript
tags= function(opts){
  opts = _.defaults(opts||{},{path:"tags/",yaml:{template:"tag.html"}});
  return function(files, metalsmith, done){
    meta = metalsmith.metadata();

    // loop through all files, building an object with data about all tags
    var tags = _.reduce(files,function(memo,file,path){
      // make sure all tags are lower case, to prevent distinction between `Backbone` and `backbone`.
      file.tags = file.tags ? _.map(file.tags,function(t){return t.toLowerCase();}) : [];
      // loop through all tags found in the `tags` YAML data for this file
      _.each(file.tags,function(tag){
        // build a path for where the file for this tag is supposed to go
        key = opts.path+tag+"/index.html";
        memo[key] = _.defaults({},memo[key],{tag:tag,posts:[],contents:""},opts.yaml);
        memo[key].posts = _.sortBy(memo[key].posts.concat(file),"date").reverse();
      });
      return memo;
    },{});

    // add this data to the files object, causing Metalsmith to create these files
    _.extend(files,tags);

    // add a taglist array to the metadata, to be consumed by a tagcloud type page
    meta.taglist = _.sortBy(_.reduce(tags,function(memo,tag){
      return memo.concat({tag:tag.tag,count:tag.posts.length,posts:tag.posts});
    },[]),"count").reverse();

    // also add the same data but with tagnames as key, for use by individual tag pages
    meta.tags = _.reduce(tags,function(memo,tag){
      memo[tag.tag] = {tag:tag.tag,count:tag.posts.length,posts:tag.posts};
      return memo;
    },{});

    // note metalsmith that we are done!
    done();
  };
};
```

## Consuming the plugin

First off, individual blog posts will print out the individual tags by simply reading from the YAML `tags` array:

```html
<div class="tags">
Tags:
{{#each tags}}
  <span><a href='../../tags/{{this}}/'>{{this}}</a></span>
{{/each}}
</div>
```

Our taglist page contains this code, using the `taglist` metadata added by our plugin:

```html
<div class='tags'>
  Tags:
  {{#each this.taglist}}
  <span><a href='../tags/{{tag}}/'>{{tag}} ({{count}})</a></span>
  {{/each}}
</div>
```

The main code powering the individual tag pages will be in the html template file. Note that we added a default to the `opts` object, telling Metalsmith to use a `tags.html` file for these pages. The `contents` was merely set to an empty string - we need to have a contents specification, otherwise Metalsmith will simply skip over generating a file.

Inside the template we have access to the variables set in the `files[tagname]` object. This means we can do this in the template file:

```html
<div class="container">
  Posts about {{tag}}:
</div>
```

For these individual pages we also created a Handlebars helper, to avoid having to put too much logic into the template file. Here's how we consume it in the template:

```html
{{#tagPosts tag}}

<article class="{{post_class}}">
  <header class="post-header">
    <h2 class="post-title">
      <a href="../../{{path}}">{{{title}}}</a>
      <span class="post-meta">
        <time datetime="{{date}}">{{moment date 'MMM Do YYYY'}}</time> 
      </span>
    </h2>
      <div class='tags'>
        By: <span><a href='../../author/{{toLowerCase author}}'>{{author}}</a></span>
      </div>
      <div class="tags">
        Tags:
        {{#each tags}}
          <span><a href='../../tags/{{this}}/'>{{this}}</a></span>
        {{/each}}
      </div>
  </header>
  <section class="post-excerpt">
    <p>{{excerpt}}</p>
  </section>
</article>

{{else}}
<section class="post-content">{{portrait}} hasn't written any posts yet!</section>
{{/tagPosts}}
```

And here's the source for the `tagPosts` helper, which uses the `tags` property of the metadata to look up the corresponding information:

```javascript
Handlebars.registerHelper('tagPosts', function(tagname, options) {
  return _.reduce(this.tags[tagname].posts,function(memo,f){
    return memo+options.fn(f);
  },"");
});
```
